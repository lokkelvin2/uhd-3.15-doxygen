<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USRP Hardware Driver and USRP Manual: Device Synchronization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Ettus_Logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">USRP Hardware Driver and USRP Manual<span id="projectnumber">&#160;Version: 3.15.0.0-0-unknown</span>
   </div>
   <div id="projectbrief">UHD and USRP Manual</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('page_sync.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Device Synchronization </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sync_commonref">Common Reference Signals</a><ul><li class="level2"><a href="#sync_commonref_pps">PPS and 10 MHz reference signals</a></li>
<li class="level2"><a href="#sync_commonref_mimo">MIMO cable reference signals</a></li>
</ul>
</li>
<li class="level1"><a href="#sync_time">Synchronizing the Device Time</a><ul><li class="level2"><a href="#sync_time_reg">Method 1 - poll the USRP time registers</a></li>
<li class="level2"><a href="#sync_time_gpsdo">Method 2 - query the GPSDO for seconds</a></li>
<li class="level2"><a href="#sync_time_mimocable">Method 3 - MIMO cable</a></li>
</ul>
</li>
<li class="level1"><a href="#sync_phase">Synchronizing Channel Phase</a><ul><li class="level2"><a href="#sync_phase_cordics">Align CORDICs in the DSP</a></li>
<li class="level2"><a href="#sync_phase_lo">Align LOs in the front-end (SBX, UBX)</a></li>
<li class="level2"><a href="#sync_phase_lootherfe">Align LOs in the front-end (others)</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p >The following application notes explain how to synchronize multiple USRP devices with the goal of transmitting or receiving time-aligned samples for MIMO or other applications requiring multiple USRP devices operating synchronously.</p>
<p ><b>Note:</b> The following synchronization notes do not apply to USRP1, which does not support the advanced features available in newer products.</p>
<h1><a class="anchor" id="sync_commonref"></a>
Common Reference Signals</h1>
<p >USRP devices take two reference signals in order to synchronize clocks and time:</p>
<ul>
<li>A 10 MHz reference to provide a single frequency reference for both devices.</li>
<li>A pulse-per-second (PPS) to synchronize the sample time across devices.</li>
<li>A MIMO cable transmits an encoded time message from one device to another.</li>
</ul>
<h2><a class="anchor" id="sync_commonref_pps"></a>
PPS and 10 MHz reference signals</h2>
<p >Connect the front panel SMA connectors to the reference sources. Typically, these signals are provided by an external GPSDO. However, some USRP models can provide these signals from an optional internal GPSDO.</p>
<div class="fragment"><div class="line">usrp-&gt;set_clock_source(<span class="stringliteral">&quot;external&quot;</span>);</div>
<div class="line">usrp-&gt;set_time_source(<span class="stringliteral">&quot;external&quot;</span>);</div>
</div><!-- fragment --><p ><b>Note:</b> Sometimes the delay on the PPS signal will cause it to arrive inside the timing margin the FPGA sampling clock, causing PPS edges to be separated by less or more than 100 million cycles of the FPGA clock. If this is the case, you can change the edge reference of the PPS signal with this parameter:</p>
<div class="fragment"><div class="line">usrp-&gt;set_time_source(<span class="stringliteral">&quot;_external_&quot;</span>);</div>
</div><!-- fragment --><p ><b>Note2:</b> For users generating their own signals for the external SMA connectors, the PPS should be clocked from the 10 MHz reference. See the application notes for your device for specific signal requirements.</p>
<h2><a class="anchor" id="sync_commonref_mimo"></a>
MIMO cable reference signals</h2>
<p >Use the MIMO expansion cable to share reference sources (USRP2 and N-Series). The MIMO cable can be used synchronize one device to another device. Users of the MIMO cable may use Method 1 (explained below) to synchronize multiple pairs of devices.</p>
<div class="fragment"><div class="line">usrp-&gt;set_clock_source(<span class="stringliteral">&quot;mimo&quot;</span>);</div>
<div class="line">usrp-&gt;set_time_source(<span class="stringliteral">&quot;mimo&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="sync_time"></a>
Synchronizing the Device Time</h1>
<p >The purpose of the PPS signal is to synchronously latch a time into the device. You can use the <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a75b1c5375549e6a446d686ee7d9b4e14">uhd::usrp::multi_usrp::set_time_next_pps()</a> function to either initialize the sample time to 0 or an absolute time, such as GPS time or UTC time. For the purposes of synchronizing devices, it doesn't matter what time you initialize to when using <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a75b1c5375549e6a446d686ee7d9b4e14">uhd::usrp::multi_usrp::set_time_next_pps()</a>.</p>
<h2><a class="anchor" id="sync_time_reg"></a>
Method 1 - poll the USRP time registers</h2>
<p >One way to initialize the PPS edge is to poll the "last PPS" time from the USRP device. When the last PPS time increments, the user can determine that a PPS has occurred:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a> last_pps_time = usrp-&gt;get_time_last_pps();</div>
<div class="line"><span class="keywordflow">while</span> (last_pps_time == usrp-&gt;get_time_last_pps()){</div>
<div class="line">    <span class="comment">//sleep 100 milliseconds (give or take)</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// This command will be processed fairly soon after the last PPS edge:</span></div>
<div class="line">usrp-&gt;set_time_next_pps(<a class="code hl_class" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a>(0.0));</div>
<div class="ttc" id="aclassuhd_1_1time__spec__t_html"><div class="ttname"><a href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a></div><div class="ttdef"><b>Definition:</b> time_spec.hpp:32</div></div>
</div><!-- fragment --><h2><a class="anchor" id="sync_time_gpsdo"></a>
Method 2 - query the GPSDO for seconds</h2>
<p >Most GPSDOs can be configured to output a NMEA string over the serial port once every PPS. The user can wait for this string to determine the PPS edge, and the user can also parse this string to determine GPS time:</p>
<div class="fragment"><div class="line"><span class="comment">//call user&#39;s function to wait for NMEA message...</span></div>
<div class="line">usrp-&gt;set_time_next_pps(<a class="code hl_class" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a>(0.0));</div>
<div class="line"> </div>
<div class="line">-- OR --</div>
<div class="line"> </div>
<div class="line"><span class="comment">//call user&#39;s function to wait for NMEA message...</span></div>
<div class="line"><span class="comment">//call user&#39;s function to parse the NMEA message...</span></div>
<div class="line">gps_time = VALUE_IN_NMEA_MESSAGE;</div>
<div class="line"><span class="comment">// At the next PPS edge, set the device time to the GPS time:</span></div>
<div class="line">usrp-&gt;set_time_next_pps(<a class="code hl_class" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a>(gps_time+1));</div>
<div class="line"><span class="comment">// Now the device time should be in sync with the GPS time.</span></div>
</div><!-- fragment --><p >Take a look at the <code>sync_to_gps</code> example for more detail.</p>
<h2><a class="anchor" id="sync_time_mimocable"></a>
Method 3 - MIMO cable</h2>
<p >Note: This only applies to USRP2 and N200/N210. This method does <em>not</em> require a separate PPS input to the devices, but it is limited to a total of 2 USRPs.</p>
<p >A USRP2 device can synchronize its time to another USRP device via the MIMO cable. Unlike the other methods, this does not use a real "pulse
per second". Rather, the USRP device sends an encoded time message over the MIMO cable. The slave device will automatically synchronize to the time on the master device. See <a class="el" href="page_usrp2.html#usrp2_mimocable">Using the MIMO Cable</a> for more detail.</p>
<h1><a class="anchor" id="sync_phase"></a>
Synchronizing Channel Phase</h1>
<h2><a class="anchor" id="sync_phase_cordics"></a>
Align CORDICs in the DSP</h2>
<p >In order to achieve phase alignment between USRP devices, the CORDICS in both devices must be aligned with respect to each other. This is easily achieved by issuing stream commands with a time spec property, which instructs the streaming to begin at a specified time. Since the devices are already synchronized via the 10 MHz and PPS inputs, the streaming will start at exactly the same time on both devices. The CORDICs are reset at each start-of-burst command, so users should ensure that every start-of-burst also has a time spec set.</p>
<p >For receive, a burst is started when the user issues a stream command. This stream command should have a time spec set:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structuhd_1_1stream__cmd__t.html">uhd::stream_cmd_t</a> stream_cmd(<a class="code hl_enumvalue" href="structuhd_1_1stream__cmd__t.html#a4df1f2e22148b7e09ace0eca0dfbf904a0e293a4a7cab198a4f6cb0e196ca377d">uhd::stream_cmd_t::STREAM_MODE_NUM_SAMPS_AND_DONE</a>);</div>
<div class="line">stream_cmd.num_samps = samps_to_recv;</div>
<div class="line">stream_cmd.stream_now = <span class="keyword">false</span>;</div>
<div class="line">stream_cmd.time_spec = time_to_recv;</div>
<div class="line">usrp-&gt;issue_stream_cmd(stream_cmd);</div>
<div class="ttc" id="astructuhd_1_1stream__cmd__t_html"><div class="ttname"><a href="structuhd_1_1stream__cmd__t.html">uhd::stream_cmd_t</a></div><div class="ttdef"><b>Definition:</b> stream_cmd.hpp:37</div></div>
<div class="ttc" id="astructuhd_1_1stream__cmd__t_html_a4df1f2e22148b7e09ace0eca0dfbf904a0e293a4a7cab198a4f6cb0e196ca377d"><div class="ttname"><a href="structuhd_1_1stream__cmd__t.html#a4df1f2e22148b7e09ace0eca0dfbf904a0e293a4a7cab198a4f6cb0e196ca377d">uhd::stream_cmd_t::STREAM_MODE_NUM_SAMPS_AND_DONE</a></div><div class="ttdeci">@ STREAM_MODE_NUM_SAMPS_AND_DONE</div><div class="ttdef"><b>Definition:</b> stream_cmd.hpp:41</div></div>
</div><!-- fragment --><p >For transmit, a burst is started when the user calls send(). The metadata should have a time spec set: :</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structuhd_1_1tx__metadata__t.html">uhd::tx_metadata_t</a> md;</div>
<div class="line">md.<a class="code hl_variable" href="structuhd_1_1tx__metadata__t.html#ab5ffe812f8d3d1870253e98e6ff1718a">start_of_burst</a> = <span class="keyword">true</span>;</div>
<div class="line">md.<a class="code hl_variable" href="structuhd_1_1tx__metadata__t.html#a00543aaaeb5a5d67b212778d6b5f1b53">end_of_burst</a> = <span class="keyword">false</span>;</div>
<div class="line">md.<a class="code hl_variable" href="structuhd_1_1tx__metadata__t.html#af8f34976fc468381bfc662f57a398360">has_time_spec</a> = <span class="keyword">true</span>;</div>
<div class="line">md.<a class="code hl_variable" href="structuhd_1_1tx__metadata__t.html#acf9881a671ba4651a2b4e3187ec23da7">time_spec</a> = time_to_send;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//send a single packet</span></div>
<div class="line"><span class="keywordtype">size_t</span> num_tx_samps = tx_streamer-&gt;send(buffs, samps_to_send, md);</div>
<div class="ttc" id="astructuhd_1_1tx__metadata__t_html"><div class="ttname"><a href="structuhd_1_1tx__metadata__t.html">uhd::tx_metadata_t</a></div><div class="ttdef"><b>Definition:</b> metadata.hpp:136</div></div>
<div class="ttc" id="astructuhd_1_1tx__metadata__t_html_a00543aaaeb5a5d67b212778d6b5f1b53"><div class="ttname"><a href="structuhd_1_1tx__metadata__t.html#a00543aaaeb5a5d67b212778d6b5f1b53">uhd::tx_metadata_t::end_of_burst</a></div><div class="ttdeci">bool end_of_burst</div><div class="ttdoc">Set end of burst to true for the last packet in the chain.</div><div class="ttdef"><b>Definition:</b> metadata.hpp:151</div></div>
<div class="ttc" id="astructuhd_1_1tx__metadata__t_html_ab5ffe812f8d3d1870253e98e6ff1718a"><div class="ttname"><a href="structuhd_1_1tx__metadata__t.html#ab5ffe812f8d3d1870253e98e6ff1718a">uhd::tx_metadata_t::start_of_burst</a></div><div class="ttdeci">bool start_of_burst</div><div class="ttdoc">Set start of burst to true for the first packet in the chain.</div><div class="ttdef"><b>Definition:</b> metadata.hpp:148</div></div>
<div class="ttc" id="astructuhd_1_1tx__metadata__t_html_acf9881a671ba4651a2b4e3187ec23da7"><div class="ttname"><a href="structuhd_1_1tx__metadata__t.html#acf9881a671ba4651a2b4e3187ec23da7">uhd::tx_metadata_t::time_spec</a></div><div class="ttdeci">time_spec_t time_spec</div><div class="ttdoc">When to send the first sample.</div><div class="ttdef"><b>Definition:</b> metadata.hpp:145</div></div>
<div class="ttc" id="astructuhd_1_1tx__metadata__t_html_af8f34976fc468381bfc662f57a398360"><div class="ttname"><a href="structuhd_1_1tx__metadata__t.html#af8f34976fc468381bfc662f57a398360">uhd::tx_metadata_t::has_time_spec</a></div><div class="ttdeci">bool has_time_spec</div><div class="ttdef"><b>Definition:</b> metadata.hpp:142</div></div>
</div><!-- fragment --><h2><a class="anchor" id="sync_phase_lo"></a>
Align LOs in the front-end (SBX, UBX)</h2>
<p >Using timed commands, multiple frontends can be tuned at a specific time. This timed-tuning ensures that the phase offsets between VCO/PLL chains will remain constant after each re-tune. See notes below:</p>
<ul>
<li>Phase synchronization with the UBX is only supported on the X3x0 Series</li>
<li>Phase synchronization with the SBX works on both N2x0 and X3x0 Series</li>
<li>There is a random phase offset between any two frontends</li>
<li>This phase offset is different for different LO frequencies</li>
<li>This phase offset remains constant after retuning</li>
<li>This phase offset will drift over time due to thermal and other characteristics</li>
<li>Periodic calibration will be necessary for phase-coherent applications</li>
</ul>
<p >Code snippet example, tuning with timed commands:</p>
<div class="fragment"><div class="line"><span class="comment">//we will tune the frontends in 100ms from now</span></div>
<div class="line"><a class="code hl_class" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a> cmd_time = usrp-&gt;get_time_now() + <a class="code hl_class" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a>(0.1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//sets command time on all devices</span></div>
<div class="line"><span class="comment">//the next commands are all timed</span></div>
<div class="line">usrp-&gt;set_command_time(cmd_time);</div>
<div class="line"> </div>
<div class="line"><span class="comment">//tune channel 0 and channel 1</span></div>
<div class="line">usrp-&gt;set_rx_freq(1.03e9, 0); <span class="comment">// Channel 0</span></div>
<div class="line">usrp-&gt;set_rx_freq(1.03e9, 1); <span class="comment">// Channel 1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//end timed commands</span></div>
<div class="line">usrp-&gt;clear_command_time();</div>
</div><!-- fragment --><h2><a class="anchor" id="sync_phase_lootherfe"></a>
Align LOs in the front-end (others)</h2>
<p >After tuning the RF front-ends, each local oscillator may have a random phase offset due to the dividers in the VCO/PLL chains. This offset will remain constant after the device has been initialized, and will remain constant until the device is closed or re-tuned. This phase offset is typically removed by the user in MIMO applications, using a training sequence to estimate the offset. It will be necessary to re-align the LOs after each tune command. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
